// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messenger.proto

#ifndef PROTOBUF_messenger_2eproto__INCLUDED
#define PROTOBUF_messenger_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace messenger {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_messenger_2eproto();
void protobuf_AssignDesc_messenger_2eproto();
void protobuf_ShutdownFile_messenger_2eproto();

class LoginReply;
class LoginRequest;
class PendingMessagesReply;
class PendingMessagesRequest;
class ResultReply;
class TextMessage;

enum ResultReply_Result {
  ResultReply_Result_SUCCESS = 0,
  ResultReply_Result_FAILED = 1,
  ResultReply_Result_ResultReply_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ResultReply_Result_ResultReply_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ResultReply_Result_IsValid(int value);
const ResultReply_Result ResultReply_Result_Result_MIN = ResultReply_Result_SUCCESS;
const ResultReply_Result ResultReply_Result_Result_MAX = ResultReply_Result_FAILED;
const int ResultReply_Result_Result_ARRAYSIZE = ResultReply_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResultReply_Result_descriptor();
inline const ::std::string& ResultReply_Result_Name(ResultReply_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResultReply_Result_descriptor(), value);
}
inline bool ResultReply_Result_Parse(
    const ::std::string& name, ResultReply_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResultReply_Result>(
    ResultReply_Result_descriptor(), name, value);
}
// ===================================================================

class ResultReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messenger.ResultReply) */ {
 public:
  ResultReply();
  virtual ~ResultReply();

  ResultReply(const ResultReply& from);

  inline ResultReply& operator=(const ResultReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultReply& default_instance();

  void Swap(ResultReply* other);

  // implements Message ----------------------------------------------

  inline ResultReply* New() const { return New(NULL); }

  ResultReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultReply& from);
  void MergeFrom(const ResultReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResultReply_Result Result;
  static const Result SUCCESS =
    ResultReply_Result_SUCCESS;
  static const Result FAILED =
    ResultReply_Result_FAILED;
  static inline bool Result_IsValid(int value) {
    return ResultReply_Result_IsValid(value);
  }
  static const Result Result_MIN =
    ResultReply_Result_Result_MIN;
  static const Result Result_MAX =
    ResultReply_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    ResultReply_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return ResultReply_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return ResultReply_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return ResultReply_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .messenger.ResultReply.Result result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::messenger::ResultReply_Result result() const;
  void set_result(::messenger::ResultReply_Result value);

  // @@protoc_insertion_point(class_scope:messenger.ResultReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int result_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messenger_2eproto();
  friend void protobuf_AssignDesc_messenger_2eproto();
  friend void protobuf_ShutdownFile_messenger_2eproto();

  void InitAsDefaultInstance();
  static ResultReply* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messenger.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const { return New(NULL); }

  LoginRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:messenger.LoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messenger_2eproto();
  friend void protobuf_AssignDesc_messenger_2eproto();
  friend void protobuf_ShutdownFile_messenger_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messenger.LoginReply) */ {
 public:
  LoginReply();
  virtual ~LoginReply();

  LoginReply(const LoginReply& from);

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReply& default_instance();

  void Swap(LoginReply* other);

  // implements Message ----------------------------------------------

  inline LoginReply* New() const { return New(NULL); }

  LoginReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReply& from);
  void MergeFrom(const LoginReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .messenger.ResultReply result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::messenger::ResultReply& result() const;
  ::messenger::ResultReply* mutable_result();
  ::messenger::ResultReply* release_result();
  void set_allocated_result(::messenger::ResultReply* result);

  // optional uint32 user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // optional uint64 time_stamp = 3;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  ::google::protobuf::uint64 time_stamp() const;
  void set_time_stamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:messenger.LoginReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::messenger::ResultReply* result_;
  ::google::protobuf::uint64 time_stamp_;
  ::google::protobuf::uint32 user_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messenger_2eproto();
  friend void protobuf_AssignDesc_messenger_2eproto();
  friend void protobuf_ShutdownFile_messenger_2eproto();

  void InitAsDefaultInstance();
  static LoginReply* default_instance_;
};
// -------------------------------------------------------------------

class TextMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messenger.TextMessage) */ {
 public:
  TextMessage();
  virtual ~TextMessage();

  TextMessage(const TextMessage& from);

  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextMessage& default_instance();

  void Swap(TextMessage* other);

  // implements Message ----------------------------------------------

  inline TextMessage* New() const { return New(NULL); }

  TextMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextMessage& from);
  void MergeFrom(const TextMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // optional string text_message = 2;
  void clear_text_message();
  static const int kTextMessageFieldNumber = 2;
  const ::std::string& text_message() const;
  void set_text_message(const ::std::string& value);
  void set_text_message(const char* value);
  void set_text_message(const char* value, size_t size);
  ::std::string* mutable_text_message();
  ::std::string* release_text_message();
  void set_allocated_text_message(::std::string* text_message);

  // optional uint64 time_stamp = 3;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  ::google::protobuf::uint64 time_stamp() const;
  void set_time_stamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:messenger.TextMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr text_message_;
  ::google::protobuf::uint64 time_stamp_;
  ::google::protobuf::uint32 user_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messenger_2eproto();
  friend void protobuf_AssignDesc_messenger_2eproto();
  friend void protobuf_ShutdownFile_messenger_2eproto();

  void InitAsDefaultInstance();
  static TextMessage* default_instance_;
};
// -------------------------------------------------------------------

class PendingMessagesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messenger.PendingMessagesRequest) */ {
 public:
  PendingMessagesRequest();
  virtual ~PendingMessagesRequest();

  PendingMessagesRequest(const PendingMessagesRequest& from);

  inline PendingMessagesRequest& operator=(const PendingMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PendingMessagesRequest& default_instance();

  void Swap(PendingMessagesRequest* other);

  // implements Message ----------------------------------------------

  inline PendingMessagesRequest* New() const { return New(NULL); }

  PendingMessagesRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PendingMessagesRequest& from);
  void MergeFrom(const PendingMessagesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PendingMessagesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 time_stamp = 1;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  ::google::protobuf::uint64 time_stamp() const;
  void set_time_stamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:messenger.PendingMessagesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 time_stamp_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messenger_2eproto();
  friend void protobuf_AssignDesc_messenger_2eproto();
  friend void protobuf_ShutdownFile_messenger_2eproto();

  void InitAsDefaultInstance();
  static PendingMessagesRequest* default_instance_;
};
// -------------------------------------------------------------------

class PendingMessagesReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messenger.PendingMessagesReply) */ {
 public:
  PendingMessagesReply();
  virtual ~PendingMessagesReply();

  PendingMessagesReply(const PendingMessagesReply& from);

  inline PendingMessagesReply& operator=(const PendingMessagesReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PendingMessagesReply& default_instance();

  void Swap(PendingMessagesReply* other);

  // implements Message ----------------------------------------------

  inline PendingMessagesReply* New() const { return New(NULL); }

  PendingMessagesReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PendingMessagesReply& from);
  void MergeFrom(const PendingMessagesReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PendingMessagesReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .messenger.ResultReply result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::messenger::ResultReply& result() const;
  ::messenger::ResultReply* mutable_result();
  ::messenger::ResultReply* release_result();
  void set_allocated_result(::messenger::ResultReply* result);

  // repeated string text_messages = 2;
  int text_messages_size() const;
  void clear_text_messages();
  static const int kTextMessagesFieldNumber = 2;
  const ::std::string& text_messages(int index) const;
  ::std::string* mutable_text_messages(int index);
  void set_text_messages(int index, const ::std::string& value);
  void set_text_messages(int index, const char* value);
  void set_text_messages(int index, const char* value, size_t size);
  ::std::string* add_text_messages();
  void add_text_messages(const ::std::string& value);
  void add_text_messages(const char* value);
  void add_text_messages(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& text_messages() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_text_messages();

  // @@protoc_insertion_point(class_scope:messenger.PendingMessagesReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::messenger::ResultReply* result_;
  ::google::protobuf::RepeatedPtrField< ::std::string> text_messages_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messenger_2eproto();
  friend void protobuf_AssignDesc_messenger_2eproto();
  friend void protobuf_ShutdownFile_messenger_2eproto();

  void InitAsDefaultInstance();
  static PendingMessagesReply* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ResultReply

// optional .messenger.ResultReply.Result result = 1;
inline void ResultReply::clear_result() {
  result_ = 0;
}
inline ::messenger::ResultReply_Result ResultReply::result() const {
  // @@protoc_insertion_point(field_get:messenger.ResultReply.result)
  return static_cast< ::messenger::ResultReply_Result >(result_);
}
inline void ResultReply::set_result(::messenger::ResultReply_Result value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:messenger.ResultReply.result)
}

// -------------------------------------------------------------------

// LoginRequest

// optional string user_name = 1;
inline void LoginRequest::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::user_name() const {
  // @@protoc_insertion_point(field_get:messenger.LoginRequest.user_name)
  return user_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:messenger.LoginRequest.user_name)
}
inline void LoginRequest::set_user_name(const char* value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:messenger.LoginRequest.user_name)
}
inline void LoginRequest::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:messenger.LoginRequest.user_name)
}
inline ::std::string* LoginRequest::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:messenger.LoginRequest.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:messenger.LoginRequest.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:messenger.LoginRequest.user_name)
}

// -------------------------------------------------------------------

// LoginReply

// optional .messenger.ResultReply result = 1;
inline bool LoginReply::has_result() const {
  return !_is_default_instance_ && result_ != NULL;
}
inline void LoginReply::clear_result() {
  if (GetArenaNoVirtual() == NULL && result_ != NULL) delete result_;
  result_ = NULL;
}
inline const ::messenger::ResultReply& LoginReply::result() const {
  // @@protoc_insertion_point(field_get:messenger.LoginReply.result)
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::messenger::ResultReply* LoginReply::mutable_result() {
  
  if (result_ == NULL) {
    result_ = new ::messenger::ResultReply;
  }
  // @@protoc_insertion_point(field_mutable:messenger.LoginReply.result)
  return result_;
}
inline ::messenger::ResultReply* LoginReply::release_result() {
  // @@protoc_insertion_point(field_release:messenger.LoginReply.result)
  
  ::messenger::ResultReply* temp = result_;
  result_ = NULL;
  return temp;
}
inline void LoginReply::set_allocated_result(::messenger::ResultReply* result) {
  delete result_;
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:messenger.LoginReply.result)
}

// optional uint32 user_id = 2;
inline void LoginReply::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 LoginReply::user_id() const {
  // @@protoc_insertion_point(field_get:messenger.LoginReply.user_id)
  return user_id_;
}
inline void LoginReply::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:messenger.LoginReply.user_id)
}

// optional uint64 time_stamp = 3;
inline void LoginReply::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LoginReply::time_stamp() const {
  // @@protoc_insertion_point(field_get:messenger.LoginReply.time_stamp)
  return time_stamp_;
}
inline void LoginReply::set_time_stamp(::google::protobuf::uint64 value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:messenger.LoginReply.time_stamp)
}

// -------------------------------------------------------------------

// TextMessage

// optional uint32 user_id = 1;
inline void TextMessage::clear_user_id() {
  user_id_ = 0u;
}
inline ::google::protobuf::uint32 TextMessage::user_id() const {
  // @@protoc_insertion_point(field_get:messenger.TextMessage.user_id)
  return user_id_;
}
inline void TextMessage::set_user_id(::google::protobuf::uint32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:messenger.TextMessage.user_id)
}

// optional string text_message = 2;
inline void TextMessage::clear_text_message() {
  text_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextMessage::text_message() const {
  // @@protoc_insertion_point(field_get:messenger.TextMessage.text_message)
  return text_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextMessage::set_text_message(const ::std::string& value) {
  
  text_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:messenger.TextMessage.text_message)
}
inline void TextMessage::set_text_message(const char* value) {
  
  text_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:messenger.TextMessage.text_message)
}
inline void TextMessage::set_text_message(const char* value, size_t size) {
  
  text_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:messenger.TextMessage.text_message)
}
inline ::std::string* TextMessage::mutable_text_message() {
  
  // @@protoc_insertion_point(field_mutable:messenger.TextMessage.text_message)
  return text_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextMessage::release_text_message() {
  // @@protoc_insertion_point(field_release:messenger.TextMessage.text_message)
  
  return text_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextMessage::set_allocated_text_message(::std::string* text_message) {
  if (text_message != NULL) {
    
  } else {
    
  }
  text_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text_message);
  // @@protoc_insertion_point(field_set_allocated:messenger.TextMessage.text_message)
}

// optional uint64 time_stamp = 3;
inline void TextMessage::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TextMessage::time_stamp() const {
  // @@protoc_insertion_point(field_get:messenger.TextMessage.time_stamp)
  return time_stamp_;
}
inline void TextMessage::set_time_stamp(::google::protobuf::uint64 value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:messenger.TextMessage.time_stamp)
}

// -------------------------------------------------------------------

// PendingMessagesRequest

// optional uint64 time_stamp = 1;
inline void PendingMessagesRequest::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PendingMessagesRequest::time_stamp() const {
  // @@protoc_insertion_point(field_get:messenger.PendingMessagesRequest.time_stamp)
  return time_stamp_;
}
inline void PendingMessagesRequest::set_time_stamp(::google::protobuf::uint64 value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:messenger.PendingMessagesRequest.time_stamp)
}

// -------------------------------------------------------------------

// PendingMessagesReply

// optional .messenger.ResultReply result = 1;
inline bool PendingMessagesReply::has_result() const {
  return !_is_default_instance_ && result_ != NULL;
}
inline void PendingMessagesReply::clear_result() {
  if (GetArenaNoVirtual() == NULL && result_ != NULL) delete result_;
  result_ = NULL;
}
inline const ::messenger::ResultReply& PendingMessagesReply::result() const {
  // @@protoc_insertion_point(field_get:messenger.PendingMessagesReply.result)
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::messenger::ResultReply* PendingMessagesReply::mutable_result() {
  
  if (result_ == NULL) {
    result_ = new ::messenger::ResultReply;
  }
  // @@protoc_insertion_point(field_mutable:messenger.PendingMessagesReply.result)
  return result_;
}
inline ::messenger::ResultReply* PendingMessagesReply::release_result() {
  // @@protoc_insertion_point(field_release:messenger.PendingMessagesReply.result)
  
  ::messenger::ResultReply* temp = result_;
  result_ = NULL;
  return temp;
}
inline void PendingMessagesReply::set_allocated_result(::messenger::ResultReply* result) {
  delete result_;
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:messenger.PendingMessagesReply.result)
}

// repeated string text_messages = 2;
inline int PendingMessagesReply::text_messages_size() const {
  return text_messages_.size();
}
inline void PendingMessagesReply::clear_text_messages() {
  text_messages_.Clear();
}
inline const ::std::string& PendingMessagesReply::text_messages(int index) const {
  // @@protoc_insertion_point(field_get:messenger.PendingMessagesReply.text_messages)
  return text_messages_.Get(index);
}
inline ::std::string* PendingMessagesReply::mutable_text_messages(int index) {
  // @@protoc_insertion_point(field_mutable:messenger.PendingMessagesReply.text_messages)
  return text_messages_.Mutable(index);
}
inline void PendingMessagesReply::set_text_messages(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:messenger.PendingMessagesReply.text_messages)
  text_messages_.Mutable(index)->assign(value);
}
inline void PendingMessagesReply::set_text_messages(int index, const char* value) {
  text_messages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:messenger.PendingMessagesReply.text_messages)
}
inline void PendingMessagesReply::set_text_messages(int index, const char* value, size_t size) {
  text_messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:messenger.PendingMessagesReply.text_messages)
}
inline ::std::string* PendingMessagesReply::add_text_messages() {
  // @@protoc_insertion_point(field_add_mutable:messenger.PendingMessagesReply.text_messages)
  return text_messages_.Add();
}
inline void PendingMessagesReply::add_text_messages(const ::std::string& value) {
  text_messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:messenger.PendingMessagesReply.text_messages)
}
inline void PendingMessagesReply::add_text_messages(const char* value) {
  text_messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:messenger.PendingMessagesReply.text_messages)
}
inline void PendingMessagesReply::add_text_messages(const char* value, size_t size) {
  text_messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:messenger.PendingMessagesReply.text_messages)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PendingMessagesReply::text_messages() const {
  // @@protoc_insertion_point(field_list:messenger.PendingMessagesReply.text_messages)
  return text_messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PendingMessagesReply::mutable_text_messages() {
  // @@protoc_insertion_point(field_mutable_list:messenger.PendingMessagesReply.text_messages)
  return &text_messages_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace messenger

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::messenger::ResultReply_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::messenger::ResultReply_Result>() {
  return ::messenger::ResultReply_Result_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messenger_2eproto__INCLUDED
